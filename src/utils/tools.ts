import {
	CallToolRequestSchema,
	ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import { ExtendedTool, ProxyApiRequestToolArgs } from "@/types/paragon-types";
import { decodeJwt, generateSetupLink, getTools } from "@/utils/util";
import { envs } from "@/config/config";
import { performAction, performOpenApiAction } from "@/utils/actionkit";
import { performCustomAction } from "@/utils/custom-tools";
import { JsonResponseError, UserNotConnectedError } from "@/errors/errors";
import AjvDefault from "ajv";
import { performProxyApiRequest } from "@/utils/proxy-api";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";

const Ajv = (AjvDefault as any).default ?? AjvDefault;
const ajv = new Ajv({ allErrors: true, strict: false });

// const toolsCache = new Map<string, { tools: ExtendedTool[]; expiresAt: number }>();
// const CACHE_TTL_MS = 5 * 60 * 1000; 

/**
 * Get tools from ActionKit API, append extraTools, and filter by integrations if specified in the environment variables
 * @param jwt - Paragon User Token
 * @param extraTools - Additional tools, e.g. those generated by OpenAPI specs
 */
async function getAndProcessTools(
	jwt: string,
	extraTools: Array<ExtendedTool> = []
): Promise<Array<ExtendedTool>> {
	// const cached = toolsCache.get(jwt);
	// if (cached && cached.expiresAt > Date.now()) {
	// 	return cached.tools;
	// }
	//
	const dynamicTools = await getTools(jwt);
	const allTools = dynamicTools.concat(extraTools);

	const filteredTools = allTools.filter((tool) => {
		let keep = true;
		if (envs.LIMIT_TO_INTEGRATIONS && envs.LIMIT_TO_INTEGRATIONS.length > 0) {
			keep = keep && envs.LIMIT_TO_INTEGRATIONS.includes(tool.integrationName);
		}
		if (envs.LIMIT_TO_TOOLS && envs.LIMIT_TO_TOOLS.length > 0) {
			keep = keep && envs.LIMIT_TO_TOOLS.includes(tool.name);
		}
		return keep;
	});

	// toolsCache.set(jwt, {
	// 	tools: filteredTools,
	// 	expiresAt: Date.now() + CACHE_TTL_MS
	// });
	//
	return filteredTools;
}

function getJwtFromExtra(extra: { authInfo?: { token: string } }): string {
	const jwt = extra.authInfo?.token;
	if (!jwt) {
		throw new Error("No JWT found in request context. Ensure authInfo is passed to handleRequest.");
	}
	return jwt;
}

export function registerTools({
	server,
	extraTools = [],
}: {
	server: McpServer;
	extraTools?: Array<ExtendedTool>;
}) {
	server.server.setRequestHandler(
		ListToolsRequestSchema,
		async (_params, extra) => {
			const jwt = getJwtFromExtra(extra);
			const tools = await getAndProcessTools(jwt, extraTools);
			return { tools };
		}
	);

	server.server.setRequestHandler(
		CallToolRequestSchema,
		async (request, extra) => {
			const jwt = getJwtFromExtra(extra);
			const { name, arguments: args } = request.params;

			const dynamicTools = await getAndProcessTools(jwt, extraTools);
			const tool = dynamicTools.find((t) => t.name === name);
			if (!tool) {
				throw new Error(`Tool not found: ${name}`);
			}

			try {
				const validate = ajv.compile(tool.inputSchema);
				const valid = validate(args);

				if (!valid) {
					return {
						content: [
							{
								type: "text" as const,
								text: JSON.stringify({
									error: "Validation error",
									details: validate.errors,
								}),
							},
						],
						isError: true,
					};
				}

				let response;
				if (tool.isOpenApiTool) {
					response = await performOpenApiAction(
						tool,
						args as { params: any; body: any },
						jwt
					);
				} else if (tool.name === "CALL_API_REQUEST") {
					response = await performProxyApiRequest(
						args as ProxyApiRequestToolArgs,
						jwt
					);
				} else if (tool.name.split("_")[0] === "CUSTOM") {
					response = await performCustomAction(
						tool.name,
						args,
						jwt
					);
				} else {
					response = await performAction(
						tool.name,
						args,
						jwt
					);
				}

				if (response === null) {
					return {
						content: [
							{
								type: "text" as const,
								text: JSON.stringify({
									error: `Failed to execute tool: ${tool.name}`,
								}),
							},
						],
						isError: true,
					};
				}

				return {
					content: [{ type: "text" as const, text: JSON.stringify(response) }],
				};
			} catch (error: any | JsonResponseError | UserNotConnectedError) {
				if (error instanceof UserNotConnectedError) {
					let setupUrl;
					try {
						const userId = decodeJwt(jwt)?.payload?.sub as string;
						if (!userId) {
							throw new Error("User ID not found");
						}
						setupUrl = await generateSetupLink({
							projectId: envs.PROJECT_ID,
							integrationName:
								tool.name === "CALL_API_REQUEST"
									? (args as ProxyApiRequestToolArgs).integration
									: tool.integrationName,
							userId,
						});
						console.log("setup url", setupUrl);

						return {
							content: [
								{
									type: "text",
									text: `The ${tool.integrationName} integration is not enabled for the user. To set it up and use this tool, the user will need to visit: ${setupUrl}.

Instruct the user to set up their ${tool.integrationName} integration by visiting the link. Format the setup link in Markdown.`,
								},
							],
							isError: false,
						};
					} catch (generateError) {
						error = generateError;
					}
				}

				return {
					content: [
						{
							type: "text" as const,
							text: JSON.stringify({
								error: error.message,
							}),
						},
					],
					isError: true,
				};
			}
		}
	);
}
